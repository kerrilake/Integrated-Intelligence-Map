<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated Intelligence Map - Sacred Geometry Consciousness</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at center, #0f1419 0%, #020617 100%);
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            position: relative;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .control-panel {
            position: fixed;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid #3b82f6;
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-family: 'Arial', sans-serif;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .panel-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(59, 130, 246, 0.3);
        }

        .panel-header:hover {
            color: #60a5fa;
        }

        .collapse-btn {
            background: none;
            border: none;
            color: #60a5fa;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .collapse-btn:hover {
            color: #93c5fd;
            transform: scale(1.1);
        }

        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .panel-content.collapsed {
            max-height: 0;
            padding: 0;
            opacity: 0;
        }

        #sacredNav {
            top: 20px;
            left: 20px;
            width: 280px;
        }

        #speciesInfo {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid #3b82f6;
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        #teslaPanel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 280px;
            max-height: 280px;
            overflow-y: auto;
        }

        #intelligenceInsights {
            position: fixed;     
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 280px;
            background: rgba(15, 23, 42, 0.8);
            border: 2px solid #3b82f6;
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .dimension-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }

        .nav-btn {
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.3);
        }

        .nav-btn:hover {
            background: linear-gradient(45deg, #60a5fa, #3b82f6);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.5);
        }

        .action-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .tesla-btn {
            background: linear-gradient(45deg, #ec4899, #be185d);
            color: white;
        }

        .tesla-btn:hover {
            background: linear-gradient(45deg, #f472b6, #ec4899);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(236, 72, 153, 0.4);
        }

        .load-btn {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
        }

        .load-btn:hover {
            background: linear-gradient(45deg, #34d399, #10b981);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }

        .research-btn {
            background: linear-gradient(45deg, #f59e0b, #d97706);
            color: white;
        }

        .research-btn:hover {
            background: linear-gradient(45deg, #fbbf24, #f59e0b);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }

        .frequency-legend {
            margin-top: 15px;
        }

        .freq-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
        }

        .freq-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .freq-396 { background: #ec4899; }
        .freq-528 { background: #10b981; }
        .freq-741 { background: #8b5cf6; }
        .freq-963 { background: #f59e0b; }

        #dimensionInfo {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
            color: #60a5fa;
        }

        .species-detail {
            margin: 10px 0;
            padding: 8px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 6px;
            border-left: 3px solid #3b82f6;
        }

        .species-name {
            font-weight: bold;
            color: #60a5fa;
            font-size: 14px;
        }

        .species-scores {
            margin-top: 5px;
            font-size: 11px;
        }

        .insight-section {
            margin: 15px 0;
            padding: 10px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 6px;
            border-left: 3px solid #10b981;
        }

        .insight-title {
            font-weight: bold;
            color: #10b981;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .insight-content {
            font-size: 11px;
            line-height: 1.4;
            color: #e2e8f0;
        }

        .cosmic-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .loading-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #60a5fa;
            font-size: 18px;
            z-index: 2000;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="cosmic-background" id="cosmicBg"></div>

    <!-- Sacred Navigation Panel -->
    <div class="control-panel" id="sacredNav">
        <div class="panel-header" onclick="togglePanel('sacredNav')">
            <span>🌀 Sacred Navigation</span>
            <button class="collapse-btn" id="sacredNavBtn">−</button>
        </div>
        <div class="panel-content" id="sacredNavContent">
            <div id="dimensionInfo">
                <strong>Current Dimension:</strong><br>
                <span id="currentDimension">1. Sensory Awareness</span>
            </div>
            
            <div class="dimension-nav">
                <button class="nav-btn" onclick="changeDimension(-1)">−</button>
                <button class="nav-btn" onclick="changeDimension(1)">+</button>
            </div>

            <button class="action-btn tesla-btn" onclick="activateTesla369Flow()">
                ⚡ Tesla 369 Flow
            </button>

            <button class="action-btn load-btn" onclick="loadSampleData()">
                🧬 Load Sample Data
            </button>

            <button class="action-btn research-btn" onclick="loadFromResearchApp()">
                📊 Load from Research App
            </button>
        </div>
    </div>

    <!-- Tesla Frequencies Panel -->
    <div class="control-panel" id="teslaPanel">
        <div class="panel-header" onclick="togglePanel('teslaPanel')">
            <span>⚡ Tesla Frequencies</span>
            <button class="collapse-btn" id="teslaPanelBtn">−</button>
        </div>
        <div class="panel-content" id="teslaPanelContent">
            <div class="frequency-legend">
                <div class="freq-item">
                    <div class="freq-color freq-396"></div>
                    <span>396Hz Liberation</span>
                </div>
                <div class="freq-item">
                    <div class="freq-color freq-528"></div>
                    <span>528Hz Love/DNA</span>
                </div>
                <div class="freq-item">
                    <div class="freq-color freq-741"></div>
                    <span>741Hz Intuition</span>
                </div>
                <div class="freq-item">
                    <div class="freq-color freq-963"></div>
                    <span>963Hz Unity</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Species Info Panel -->
    <div id="speciesInfo">
        <div class="panel-header" onclick="togglePanel('speciesInfo')">
            <span>🐾 Species Wisdom</span>
            <button class="collapse-btn" id="speciesInfoBtn">−</button>
        </div>
        <div class="panel-content" id="speciesInfoContent">
            <div id="speciesDetails"></div>
        </div>
    </div>

    <!-- Intelligence Insights Panel -->
    <div id="intelligenceInsights">
        <div class="panel-header" onclick="togglePanel('intelligenceInsights')">
            <span>🔍 Intelligence Insights</span>
            <button class="collapse-btn" id="intelligenceInsightsBtn">−</button>
        </div>
        <div class="panel-content" id="intelligenceInsightsContent">
            <div id="insightDetails"></div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, vectorEquilibrium, species = [], currentDimension = 1;
        let teslaAnimation = false;
        let cameraDistance = 15;

        // 12 Sacred Dimensions of Consciousness
        const dimensions = [
            "Sensory Awareness", "Intuitive Reception", "Temporal Perception",
            "Emotional Resonance", "Energetic Attunement", "Environmental Consciousness",
            "Symbolic Communication", "Collaborative Intelligence", "Creative Innovation",
            "Healing Wisdom", "Teaching Capacity", "Evolutionary Contribution"
        ];

        // Tesla frequency colors
        const teslaColors = {
            396: 0xec4899, // Liberation - Pink
            528: 0x10b981, // Love/DNA - Green  
            741: 0x8b5cf6, // Intuition - Purple
            963: 0xf59e0b  // Unity - Gold
        };

        // Sample species data
        const sampleSpecies = [
            {
                name: "Dolphin",
                scores: [95, 90, 85, 88, 92, 87, 80, 75, 70, 85, 80, 75],
                teslaFreq: 528,
                consciousness: "Highly developed sonar consciousness with deep empathic healing abilities"
            },
            {
                name: "Honeybee",
                scores: [85, 70, 95, 65, 80, 90, 90, 95, 85, 70, 85, 88],
                teslaFreq: 963,
                consciousness: "Collective intelligence with precise temporal and spatial awareness"
            },
            {
                name: "Ancient Oak",
                scores: [80, 85, 98, 75, 95, 98, 70, 80, 75, 90, 91, 96],
                teslaFreq: 963,
                consciousness: "Deep root network consciousness connecting forest ecosystems across time"
            },
            {
                name: "Octopus",
                scores: [98, 85, 80, 70, 75, 85, 85, 70, 95, 80, 75, 70],
                teslaFreq: 396,
                consciousness: "Highly adaptive problem-solving intelligence with camouflage mastery"
            },
            {
                name: "Human",
                scores: [75, 70, 65, 80, 60, 70, 95, 85, 90, 75, 85, 80],
                teslaFreq: 396,
                consciousness: "Abstract symbolic reasoning with complex social and creative capacities"
            },
            {
                name: "Wolf",
                scores: [90, 75, 80, 85, 85, 88, 75, 90, 70, 80, 82, 75],
                teslaFreq: 741,
                consciousness: "Pack intelligence with sophisticated social hierarchies and hunting strategies"
            }
        ];

        // Initialize the application
        function init() {
            createCosmicBackground();
            setupThreeJS();
            createVectorEquilibrium();
            animate();
            updateDimensionDisplay();
        }

        function createCosmicBackground() {
            const bg = document.getElementById('cosmicBg');
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = Math.random() * 3 + 1 + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                bg.appendChild(star);
            }
        }

        function setupThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('container').appendChild(renderer.domElement);

            camera.position.set(0, 0, cameraDistance);

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Mouse controls
            let mouseDown = false, mouseX = 0, mouseY = 0;
            let targetRotationX = 0, targetRotationY = 0;
            let currentRotationX = 0, currentRotationY = 0;

            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('click', onMouseClick);

            // Create hover label element
            const hoverLabel = document.createElement('div');
            hoverLabel.id = 'hoverLabel';
            hoverLabel.style.cssText = `
                position: fixed;
                background: rgba(15, 23, 42, 0.9);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 14px;
                font-weight: bold;
                pointer-events: none;
                z-index: 2000;
                display: none;
                border: 1px solid #3b82f6;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            document.body.appendChild(hoverLabel);

            function onMouseDown(event) {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }

            function onMouseMove(event) {
                if (mouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                } else {
                    // Handle hover detection for species labels
                    const raycaster = new THREE.Raycaster();
                    const mouse = new THREE.Vector2();
                    
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    const speciesNodes = species.map(s => s.node).filter(n => n);
                    const intersects = raycaster.intersectObjects(speciesNodes);
                    
                    const hoverLabel = document.getElementById('hoverLabel');
                    
                    if (intersects.length > 0) {
                        const hoveredSpecies = species.find(s => s.node === intersects[0].object);
                        if (hoveredSpecies) {
                            hoverLabel.textContent = hoveredSpecies.name;
                            hoverLabel.style.display = 'block';
                            hoverLabel.style.left = (event.clientX + 15) + 'px';
                            hoverLabel.style.top = (event.clientY - 10) + 'px';
                            document.body.style.cursor = 'pointer';
                        }
                    } else {
                        hoverLabel.style.display = 'none';
                        document.body.style.cursor = 'default';
                    }
                }
            }

            function onMouseUp() {
                mouseDown = false;
            }

            function onMouseWheel(event) {
                cameraDistance += event.deltaY * 0.01;
                cameraDistance = Math.max(5, Math.min(30, cameraDistance));
                camera.position.set(0, 0, cameraDistance);
            }

            function onMouseClick(event) {
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                const speciesNodes = species.map(s => s.node).filter(n => n);
                const intersects = raycaster.intersectObjects(speciesNodes);
                
                if (intersects.length > 0) {
                    const clickedSpecies = species.find(s => s.node === intersects[0].object);
                    showSpeciesInfo(clickedSpecies);
                }
            }

            // Smooth rotation
            function updateRotation() {
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                
                if (vectorEquilibrium) {
                    vectorEquilibrium.rotation.x = currentRotationX;
                    vectorEquilibrium.rotation.y = currentRotationY;
                }
            }

            // Add to animation loop
            const originalAnimate = animate;
            animate = function() {
                updateRotation();
                originalAnimate();
            };
        }

        function createVectorEquilibrium() {
            vectorEquilibrium = new THREE.Group();

            // Create proper Vector Equilibrium (Cuboctahedron) vertices
            // 6 vertices of octahedron + 8 vertices of cube = 14 vertices total
            // But we'll use 12 vertices for our 12 dimensions in proper sacred geometry
            const sqrt2 = Math.sqrt(2);
            const vertices = [
                // Inner hexagon (6 vertices) - primary consciousness dimensions
                new THREE.Vector3(3, 0, 0),     // East
                new THREE.Vector3(1.5, 2.6, 0), // Northeast  
                new THREE.Vector3(-1.5, 2.6, 0), // Northwest
                new THREE.Vector3(-3, 0, 0),    // West
                new THREE.Vector3(-1.5, -2.6, 0), // Southwest
                new THREE.Vector3(1.5, -2.6, 0),  // Southeast
                
                // Outer hexagon (6 vertices) - expanded consciousness dimensions
                new THREE.Vector3(2.1, 1.2, 2.5), // Upper Northeast
                new THREE.Vector3(-2.1, 1.2, 2.5), // Upper Northwest
                new THREE.Vector3(-2.1, -1.2, 2.5), // Upper Southwest
                new THREE.Vector3(2.1, -1.2, 2.5), // Upper Southeast  
                new THREE.Vector3(2.1, 1.2, -2.5), // Lower Northeast
                new THREE.Vector3(-2.1, -1.2, -2.5) // Lower Southwest
            ];

            // Create proper Vector Equilibrium edges - sacred geometry connections
            const edges = [
                // Inner hexagon
                [0,1], [1,2], [2,3], [3,4], [4,5], [5,0],
                // Connecting inner to outer (creating triangular faces)
                [0,6], [0,10], [1,6], [1,7], [2,7], [2,8], 
                [3,8], [3,9], [4,9], [4,11], [5,11], [5,10],
                // Outer connections
                [6,7], [7,8], [8,9], [9,11], [11,10], [10,6]
            ];

            // Draw edges with sacred geometry styling
            edges.forEach(edge => {
                const geometry = new THREE.BufferGeometry().setFromPoints([
                    vertices[edge[0]], vertices[edge[1]]
                ]);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x3b82f6, 
                    transparent: true, 
                    opacity: 0.4,
                    linewidth: 1
                });
                const line = new THREE.Line(geometry, material);
                vectorEquilibrium.add(line);
            });

            // Store vertices for species positioning
            vectorEquilibrium.vertices = vertices;
            scene.add(vectorEquilibrium);
        }

        function loadSampleData() {
            clearSpecies();
            
            sampleSpecies.forEach((speciesData, index) => {
                const speciesObj = createSpecies(speciesData, index);
                species.push(speciesObj);
            });
            
            createConnections();
            console.log('Sample data loaded:', species.length, 'species');
        }

        function createSpecies(speciesData, index) {
            // Position based on flower of life pattern and current dimension focus
            const position = calculateSacredPosition(speciesData, index);
            
            // Create visual node
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const color = teslaColors[speciesData.teslaFreq];
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            
            const node = new THREE.Mesh(geometry, material);
            node.position.copy(position);
            
            // Pulsing animation based on Tesla frequency
            const freq = speciesData.teslaFreq;
            node.userData.originalScale = 1;
            node.userData.pulseSpeed = freq / 200;
            
            vectorEquilibrium.add(node);
            
            return {
                ...speciesData,
                node: node,
                position: position
            };
        }

        function calculateSacredPosition(speciesData, index) {
            // Position species directly on Vector Equilibrium vertices
            if (!vectorEquilibrium.vertices || index >= vectorEquilibrium.vertices.length) {
                // Fallback to circular positioning if vertices not available
                const angle = (index * 2 * Math.PI / species.length);
                const radius = 4;
                return new THREE.Vector3(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
            }
            
            // Use actual Vector Equilibrium vertex positions
            const vertex = vectorEquilibrium.vertices[index % vectorEquilibrium.vertices.length];
            
            // Add slight dimensional variation based on current dimension score
            const dimScore = speciesData.scores[currentDimension - 1];
            const heightOffset = (dimScore - 75) / 50; // Subtle variation
            
            return new THREE.Vector3(
                vertex.x,
                vertex.y + heightOffset,
                vertex.z
            );
        }

        function createConnections() {
            // Remove existing connections
            const connectionsToRemove = [];
            vectorEquilibrium.children.forEach(child => {
                if (child.userData && child.userData.isConnection) {
                    connectionsToRemove.push(child);
                }
            });
            connectionsToRemove.forEach(conn => vectorEquilibrium.remove(conn));

            // Create meaningful connections based on shared dimensional expertise
            for (let i = 0; i < species.length; i++) {
                const connections = findMeaningfulConnections(species[i], i);
                connections.forEach(connection => {
                    createDimensionalConnection(species[i], connection.species, connection.dimension, connection.strength);
                });
            }
        }

        function findMeaningfulConnections(targetSpecies, targetIndex) {
            const connections = [];
            
            // Find top 2 dimensions for this species
            const topDimensions = targetSpecies.scores
                .map((score, index) => ({ dimension: index, score }))
                .sort((a, b) => b.score - a.score)
                .slice(0, 2);
            
            // For each top dimension, find other species that also excel in it
            topDimensions.forEach(topDim => {
                if (topDim.score < 80) return; // Only connect high-performing dimensions
                
                for (let j = 0; j < species.length; j++) {
                    if (j === targetIndex) continue;
                    
                    const otherSpecies = species[j];
                    const otherScore = otherSpecies.scores[topDim.dimension];
                    
                    // Connect if both species score 80+ in this dimension
                    if (otherScore >= 80) {
                        const avgScore = (topDim.score + otherScore) / 2;
                        const strength = Math.min(avgScore / 100, 1);
                        
                        connections.push({
                            species: otherSpecies,
                            dimension: topDim.dimension,
                            strength: strength
                        });
                    }
                }
            });
            
            // Limit to 2 strongest connections per species to avoid visual clutter
            return connections
                .sort((a, b) => b.strength - a.strength)
                .slice(0, 2);
        }

        function createDimensionalConnection(species1, species2, dimensionIndex, strength) {
            const start = species1.position;
            const end = species2.position;
            
            // Create elegant curved path
            const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            const distance = start.distanceTo(end);
            
            // Create control point for curve (higher for stronger connections)
            const controlOffset = 1 + (strength * 2);
            const perpendicular = new THREE.Vector3(0, controlOffset, 0);
            const controlPoint = midpoint.clone().add(perpendicular);
            
            const curve = new THREE.QuadraticBezierCurve3(start, controlPoint, end);
            const points = curve.getPoints(16);
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // Color-code connections by dimension category
            const dimensionColors = [
                0x10b981, 0x3b82f6, 0x8b5cf6, 0xf59e0b, 0xec4899, 0x06b6d4, // Inner dimensions 1-6
                0x84cc16, 0xf97316, 0x6366f1, 0x14b8a6, 0xf472b6, 0x22d3ee  // Outer dimensions 7-12
            ];
            
            const material = new THREE.LineBasicMaterial({
                color: dimensionColors[dimensionIndex] || 0x10b981,
                transparent: true,
                opacity: 0.6 * strength,
                linewidth: 2
            });
            
            const connection = new THREE.Line(geometry, material);
            connection.userData.isConnection = true;
            connection.userData.dimension = dimensions[dimensionIndex];
            connection.userData.strength = strength;
            
            vectorEquilibrium.add(connection);
        }

        function showSpeciesInfo(speciesData) {
            const panel = document.getElementById('speciesInfo');
            const details = document.getElementById('speciesDetails');
            const insightsPanel = document.getElementById('intelligenceInsights');
            const insightDetails = document.getElementById('insightDetails');
            
            // Show species wisdom panel
            details.innerHTML = `
                <div class="species-detail">
                    <div class="species-name">${speciesData.name}</div>
                    <div style="margin: 8px 0; font-style: italic; color: #10b981;">
                        ${speciesData.consciousness}
                    </div>
                    <div class="species-scores">
                        Tesla Frequency: ${speciesData.teslaFreq}Hz<br>
                        ${dimensions.map((dim, i) => 
                            `<strong>${dim}:</strong> ${speciesData.scores[i]}/12`
                        ).join('<br>')}
                    </div>
                </div>
            `;
            
            // Generate and show intelligence insights
            const insights = generateSpeciesInsights(speciesData);
            insightDetails.innerHTML = insights;
            
            panel.style.display = 'block';
            insightsPanel.style.display = 'block';
        }

        function generateSpeciesInsights(speciesData) {
            let insights = '';
            
            // Key Intelligence Strengths
            insights += '<div class="insight-section">';
            insights += '<div class="insight-title">🧠 Key Intelligence Strengths:</div>';
            insights += '<div class="insight-content">';
            
            // Find top 3 dimensional scores
            const topDimensions = speciesData.scores
                .map((score, index) => ({ dimension: dimensions[index], score, index }))
                .sort((a, b) => b.score - a.score)
                .slice(0, 3);
            
            topDimensions.forEach(dim => {
                const interpretation = getDimensionInterpretation(dim.dimension, dim.score, speciesData.name);
                insights += `<strong>${dim.dimension} (${dim.score}/12)</strong><br>${interpretation}<br><br>`;
            });
            
            insights += '</div></div>';
            
            // Consciousness Relationships
            insights += '<div class="insight-section">';
            insights += '<div class="insight-title">🌐 Consciousness Relationships:</div>';
            insights += '<div class="insight-content">';
            
            // Find similar species based on top dimensions
            const relationships = findRelatedSpecies(speciesData);
            relationships.forEach(rel => {
                insights += `<strong>${rel.species}</strong><br>Shares ${rel.commonDimension} consciousness, suggesting potential for ${rel.collaboration}.<br><br>`;
            });
            
            insights += '</div></div>';
            
            // Relevance for Humans
            insights += '<div class="insight-section">';
            insights += '<div class="insight-title">🌟 Relevance for Humans:</div>';
            insights += '<div class="insight-content">';
            insights += getHumanRelevance(speciesData);
            insights += '</div></div>';
            
            return insights;
        }

        function getDimensionInterpretation(dimension, score, speciesName) {
            const interpretations = {
                "Sensory Awareness": "demonstrates exceptional sensory processing abilities, perceiving environmental information beyond typical ranges",
                "Intuitive Reception": "shows remarkable intuitive intelligence, processing non-linear information and subtle environmental cues",
                "Temporal Perception": "exhibits advanced time consciousness, understanding past/future relationships and cyclical patterns",
                "Emotional Resonance": "displays deep emotional intelligence and empathic connection capabilities",
                "Energetic Attunement": "demonstrates sensitivity to energy fields and vibrational frequencies",
                "Environmental Consciousness": "shows profound awareness of ecological relationships and environmental interdependence",
                "Symbolic Communication": "exhibits sophisticated communication through symbols, patterns, and abstract concepts",
                "Collaborative Intelligence": "demonstrates exceptional group problem-solving and collective decision-making abilities",
                "Creative Innovation": "shows remarkable creative problem-solving and adaptive innovation capabilities",
                "Healing Wisdom": "demonstrates natural healing abilities and therapeutic consciousness",
                "Teaching Capacity": "exhibits exceptional ability to transmit knowledge and skills across species",
                "Evolutionary Contribution": "demonstrates profound contribution to consciousness evolution and species development"
            };
            
            return `${speciesName} ${interpretations[dimension] || "shows unique consciousness patterns in this dimension"}.`;
        }

        function findRelatedSpecies(targetSpecies) {
            const relationships = [];
            const topDims = targetSpecies.scores
                .map((score, index) => ({ dimension: dimensions[index], score, index }))
                .sort((a, b) => b.score - a.score)
                .slice(0, 2);
            
            species.forEach(otherSpecies => {
                if (otherSpecies.name === targetSpecies.name) return;
                
                topDims.forEach(dim => {
                    if (otherSpecies.scores[dim.index] >= 80) {
                        const collaborationType = getCollaborationType(dim.dimension);
                        relationships.push({
                            species: otherSpecies.name,
                            commonDimension: dim.dimension,
                            collaboration: collaborationType
                        });
                    }
                });
            });
            
            return relationships.slice(0, 2); // Limit to top 2 relationships
        }

        function getCollaborationType(dimension) {
            const collaborations = {
                "Sensory Awareness": "environmental monitoring and early warning systems",
                "Intuitive Reception": "intuitive problem-solving partnerships",
                "Temporal Perception": "long-term planning and forecasting collaborations",
                "Emotional Resonance": "emotional healing and therapeutic partnerships",
                "Energetic Attunement": "energy healing and vibrational medicine applications",
                "Environmental Consciousness": "ecosystem restoration and conservation efforts",
                "Symbolic Communication": "cross-species communication bridge development",
                "Collaborative Intelligence": "group problem-solving and decision-making partnerships",
                "Creative Innovation": "innovative solution development and creative projects",
                "Healing Wisdom": "therapeutic and healing methodology development",
                "Teaching Capacity": "educational and knowledge transfer programs",
                "Evolutionary Contribution": "consciousness evolution and species advancement initiatives"
            };
            
            return collaborations[dimension] || "mutual learning and consciousness expansion";
        }

        function getHumanRelevance(speciesData) {
            const topDim = speciesData.scores
                .map((score, index) => ({ dimension: dimensions[index], score, index }))
                .sort((a, b) => b.score - a.score)[0];
            
            const relevanceMap = {
                "Sensory Awareness": "insights into developing enhanced sensory technologies and mindfulness practices for better environmental awareness",
                "Intuitive Reception": "wisdom about accessing intuitive intelligence and non-linear problem-solving approaches in business and personal development",
                "Temporal Perception": "understanding time perception for better health prediction and life planning, challenging linear time concepts",
                "Emotional Resonance": "lessons in emotional intelligence development and empathic communication for improved relationships and leadership",
                "Energetic Attunement": "insights into energy healing methodologies and vibrational medicine applications for holistic health",
                "Environmental Consciousness": "wisdom about sustainable living practices and ecological interdependence for environmental restoration",
                "Symbolic Communication": "understanding non-verbal communication and symbolic thinking for enhanced creativity and cross-cultural understanding",
                "Collaborative Intelligence": "lessons in collective problem-solving and group dynamics for improved teamwork and organizational effectiveness",
                "Creative Innovation": "insights into adaptive thinking and innovative problem-solving for technological and artistic advancement",
                "Healing Wisdom": "understanding natural healing principles and therapeutic consciousness for integrative medicine approaches",
                "Teaching Capacity": "wisdom about knowledge transmission and skill development for educational methodology advancement",
                "Evolutionary Contribution": "insights into consciousness evolution and species development for human potential advancement"
            };
            
            return `${speciesData.name}'s consciousness pattern offers humans ${relevanceMap[topDim.dimension]}. This challenges us to expand beyond human-centric intelligence definitions and recognize the profound wisdom available through interspecies relationships.`;
        }

        function changeDimension(direction) {
            currentDimension += direction;
            if (currentDimension < 1) currentDimension = 12;
            if (currentDimension > 12) currentDimension = 1;
            
            updateDimensionDisplay();
            repositionSpecies();
        }

        function updateDimensionDisplay() {
            document.getElementById('currentDimension').textContent = 
                `${currentDimension}. ${dimensions[currentDimension - 1]}`;
        }

        function repositionSpecies() {
            species.forEach((speciesData, index) => {
                const newPosition = calculateSacredPosition(speciesData, index);
                speciesData.position = newPosition;
                
                if (speciesData.node) {
                    // Animate to new position
                    const startPos = speciesData.node.position.clone();
                    const duration = 1000; // 1 second
                    const startTime = Date.now();
                    
                    function animatePosition() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                        
                        speciesData.node.position.lerpVectors(startPos, newPosition, easeProgress);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animatePosition);
                        }
                    }
                    
                    animatePosition();
                }
            });
            
            // Recreate connections after repositioning
            setTimeout(() => createConnections(), 1100);
        }

        function activateTesla369Flow() {
            teslaAnimation = !teslaAnimation;
            const btn = document.querySelector('.tesla-btn');
            
            if (teslaAnimation) {
                btn.textContent = '⚡ Stop Tesla Flow';
                btn.style.background = 'linear-gradient(45deg, #dc2626, #991b1b)';
            } else {
                btn.textContent = '⚡ Tesla 369 Flow';
                btn.style.background = 'linear-gradient(45deg, #ec4899, #be185d)';
            }
        }

        function loadFromResearchApp() {
            try {
                const researchData = localStorage.getItem('speciesResearchData');
                if (!researchData) {
                    alert('No data found from Research App. Please complete some species research first!');
                    return;
                }
                
                const data = JSON.parse(researchData);
                clearSpecies();
                
                // Convert research data to sacred geometry format
                Object.values(data).forEach((speciesData, index) => {
                    const sacredSpecies = convertToSacredFormat(speciesData, index);
                    if (sacredSpecies) {
                        const speciesObj = createSpecies(sacredSpecies, index);
                        species.push(speciesObj);
                    }
                });
                
                createConnections();
                console.log('Loaded', species.length, 'species from Research App');
                
            } catch (error) {
                console.error('Error loading from Research App:', error);
                alert('Error loading data from Research App');
            }
        }

        function convertToSacredFormat(researchData, index) {
            if (!researchData.scores) return null;
            
            // Convert 6-dimensional research data to 12-dimensional sacred geometry
            const researchScores = researchData.scores;
            const sacredScores = [
                researchScores[0] || 70, // Sensory -> Sensory Awareness
                Math.round((researchScores[1] + researchScores[0]) / 2), // Intuitive Reception
                researchScores[2] || 70, // Temporal -> Temporal Perception
                researchScores[3] || 70, // Emotional -> Emotional Resonance
                Math.round((researchScores[4] + researchScores[1]) / 2), // Energetic Attunement
                researchScores[5] || 70, // Environmental -> Environmental Consciousness
                Math.round((researchScores[0] + researchScores[3]) / 2), // Symbolic Communication
                researchScores[4] || 70, // Collaborative -> Collaborative Intelligence
                Math.round((researchScores[1] + researchScores[2]) / 2), // Creative Innovation
                Math.round((researchScores[3] + researchScores[5]) / 2), // Healing Wisdom
                Math.round((researchScores[4] + researchScores[0]) / 2), // Teaching Capacity
                Math.round((researchScores[5] + researchScores[2]) / 2)  // Evolutionary Contribution
            ];
            
            // Assign Tesla frequency based on consciousness signature
            let teslaFreq = 528; // Default
            const avgScore = sacredScores.reduce((a, b) => a + b, 0) / 12;
            if (avgScore > 85) teslaFreq = 963; // Unity
            else if (avgScore > 75) teslaFreq = 741; // Intuition
            else if (avgScore < 65) teslaFreq = 396; // Liberation
            
            return {
                name: researchData.name || `Species ${index + 1}`,
                scores: sacredScores,
                teslaFreq: teslaFreq,
                consciousness: researchData.consciousness || "Consciousness pattern derived from research analysis"
            };
        }

        function clearSpecies() {
            // Remove species nodes from scene
            species.forEach(s => {
                if (s.node) {
                    vectorEquilibrium.remove(s.node);
                }
            });
            
            // Clear connections
            const connectionsToRemove = [];
            vectorEquilibrium.children.forEach(child => {
                if (child.userData && child.userData.isConnection) {
                    connectionsToRemove.push(child);
                }
            });
            connectionsToRemove.forEach(conn => vectorEquilibrium.remove(conn));
            
            species = [];
            
            // Hide info panels
            document.getElementById('speciesInfo').style.display = 'none';
            document.getElementById('intelligenceInsights').style.display = 'none';
        }

        function togglePanel(panelId) {
            const content = document.getElementById(panelId + 'Content');
            const btn = document.getElementById(panelId + 'Btn');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                btn.textContent = '−';
            } else {
                content.classList.add('collapsed');
                btn.textContent = '+';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Tesla frequency pulsing animation
            species.forEach(speciesData => {
                if (speciesData.node) {
                    const time = Date.now() * 0.001;
                    const pulseSpeed = speciesData.node.userData.pulseSpeed;
                    
                    if (teslaAnimation) {
                        // Enhanced pulsing during Tesla flow
                        const scale = 1 + Math.sin(time * pulseSpeed * 3) * 0.3;
                        speciesData.node.scale.setScalar(scale);
                        
                        // Color pulsing
                        const intensity = 0.5 + Math.sin(time * pulseSpeed * 2) * 0.5;
                        speciesData.node.material.opacity = intensity;
                    } else {
                        // Gentle pulsing
                        const scale = 1 + Math.sin(time * pulseSpeed) * 0.1;
                        speciesData.node.scale.setScalar(scale);
                        speciesData.node.material.opacity = 0.8;
                    }
                }
            });
            
            // Gentle rotation of vector equilibrium
            if (vectorEquilibrium && !teslaAnimation) {
                vectorEquilibrium.rotation.y += 0.002;
            }
            
            if (teslaAnimation && vectorEquilibrium) {
                // Tesla 369 flow rotation
                const time = Date.now() * 0.001;
                vectorEquilibrium.rotation.y = Math.sin(time * 0.369) * 0.1;
                vectorEquilibrium.rotation.x = Math.cos(time * 0.369) * 0.05;
            }
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize the application
        init();
    </script>
</body>
</html>
