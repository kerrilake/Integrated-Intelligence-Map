<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Equilibrium Consciousness Synthesizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #e6f3ff 0%, #b3d9ff 100%);
            color: #2c3e50;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5em;
            color: #2980b9;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            color: #34495e;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
        }

        .control-button {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .control-button:active {
            transform: translateY(0);
        }

        .visualization-container {
            position: relative;
            height: 600px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin: 20px 0;
            overflow: hidden;
        }

        #vectorEquilibriumCanvas {
            width: 100%;
            height: 100%;
            border-radius: 20px;
        }

        .analysis-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            display: none;
        }

        .analysis-panel.active {
            display: block;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .analysis-title {
            font-size: 1.8em;
            color: #2980b9;
            margin-bottom: 20px;
            font-weight: 600;
            text-align: center;
        }

        .species-relationship {
            background: rgba(52, 152, 219, 0.1);
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
        }

        .species-relationship h4 {
            color: #2980b9;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .frequency-info {
            background: rgba(142, 68, 173, 0.1);
            border-left: 4px solid #8e44ad;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
        }

        .geometric-insight {
            background: rgba(39, 174, 96, 0.1);
            border-left: 4px solid #27ae60;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
        }

        .wisdom-insight {
            background: rgba(230, 126, 34, 0.1);
            border-left: 4px solid #e67e22;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-style: italic;
        }

        .research-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }

        .research-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 15px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .research-checkbox:hover {
            border-color: #3498db;
            background: rgba(255, 255, 255, 1);
        }

        .research-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            pointer-events: none;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .category-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåÄ Vector Equilibrium Consciousness Synthesizer</h1>
            <p>Dynamic Geometric Consciousness Mapping Using Sacred Geometry & Tesla Frequencies</p>
            <p style="font-size: 0.9em; color: #7f8c8d;">Exploring which combinations of intelligence types create thriving ecosystems</p>
        </div>

        <div class="category-legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #3498db;"></div>
                <span>üåä Aquatic Intelligence</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #27ae60;"></div>
                <span>üèûÔ∏è Land & Air Wisdom</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8e44ad;"></div>
                <span>üå± Living Networks</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e67e22;"></div>
                <span>üíé Earth Elements</span>
            </div>
        </div>

        <div class="controls">
            <button class="control-button" onclick="loadEcosystemTrio()">üî∫ Ecosystem Trio</button>
            <button class="control-button" onclick="loadEcosystemQuad()">‚¨ú Ecosystem Quad</button>
            <button class="control-button" onclick="loadComplexEcosystem()">‚¨¢ Complex Ecosystem</button>
            <button class="control-button" onclick="resetVisualization()">üîÑ Reset View</button>
            <button class="control-button" onclick="loadFromRedefinigApp()">üìö Load from Redefining Intelligence App</button>
        </div>

        <div class="research-controls">
            <label class="research-checkbox">
                <input type="checkbox" id="showSimilarTypes" onchange="updateAnalysis()">
                <span>Find Similar Intelligence Types</span>
            </label>
            <label class="research-checkbox">
                <input type="checkbox" id="showUniversalPatterns" onchange="updateAnalysis()">
                <span>Show Universal Patterns</span>
            </label>
            <label class="research-checkbox">
                <input type="checkbox" id="showCrossEcosystem" onchange="updateAnalysis()">
                <span>Cross-Ecosystem Matches</span>
            </label>
            <label class="research-checkbox">
                <input type="checkbox" id="showCompatibility" onchange="updateAnalysis()">
                <span>Compatibility Matrix</span>
            </label>
        </div>

        <div class="visualization-container">
            <canvas id="vectorEquilibriumCanvas"></canvas>
            <div class="tooltip" id="tooltip"></div>
        </div>

        <div id="analysisPanel" class="analysis-panel">
            <!-- Analysis content will be inserted here -->
        </div>
    </div>

    <script>
        // Species database with AI Consciousness Bridge categories
        const speciesDatabase = {
            // Aquatic Intelligence (üåä)
            dolphin: { name: 'Dolphin', category: 'aquatic', color: 0x3498db, icon: 'üê¨' },
            whale: { name: 'Whale', category: 'aquatic', color: 0x2980b9, icon: 'üêã' },
            coral: { name: 'Coral Reef', category: 'aquatic', color: 0x1abc9c, icon: 'ü™∏' },
            
            // Land & Air Wisdom (üèûÔ∏è)
            dog: { name: 'Dog', category: 'terrestrial', color: 0x27ae60, icon: 'üêï' },
            horse: { name: 'Horse', category: 'terrestrial', color: 0x2ecc71, icon: 'üê¥' },
            cow: { name: 'Cow', category: 'terrestrial', color: 0x58d68d, icon: 'üêÑ' },
            bee: { name: 'Honeybee', category: 'terrestrial', color: 0xf1c40f, icon: 'üêù' },
            crow: { name: 'Crow', category: 'terrestrial', color: 0x34495e, icon: 'ü¶Ö' },
            
            // Living Networks (üå±)
            tree: { name: 'Ancient Oak', category: 'networks', color: 0x8e44ad, icon: 'üå≥' },
            mycelium: { name: 'Mycelium Network', category: 'networks', color: 0x9b59b6, icon: 'üçÑ' },
            riparian: { name: 'Riparian Forest', category: 'networks', color: 0xaf7ac5, icon: 'üå≤' },
            
            // Earth Elements (üíé)
            crystal: { name: 'Crystal', category: 'elemental', color: 0xe67e22, icon: 'üíé' }
        };

        // Factor 9 frequency calculation
        function calculateFrequency(angle) {
            const baseFreq = angle * 2; // Convert angle to base frequency
            let freq = baseFreq;
            
            // Reduce to factor 9
            while (freq > 999) {
                const digits = freq.toString().split('').map(Number);
                freq = digits.reduce((sum, digit) => sum + digit, 0);
            }
            
            // Scale to audible/meaningful range
            if (freq < 100) freq *= 4.32; // 432Hz harmonic series
            
            return Math.round(freq);
        }

        // Frequency classification
        function classifyFrequency(freq) {
            const sacredFreqs = [144, 288, 432, 528, 741, 852, 963];
            const factor9Freqs = [108, 216, 324, 432, 540, 648, 756, 864, 972];
            
            if (sacredFreqs.some(sf => Math.abs(freq - sf) < 10)) {
                return { type: 'Resonant', description: 'Sacred geometry frequency with special mathematical significance' };
            } else if (factor9Freqs.some(ff => Math.abs(freq - ff) < 10)) {
                return { type: 'Factor 9', description: 'Mathematical harmony frequency from the Factor 9 grid' };
            } else {
                return { type: 'Unique', description: 'Distinctive frequency pattern with unique characteristics' };
            }
        }

        // Three.js setup
        let scene, camera, renderer, vectorEquilibrium, activeSpecies = [];
        let speciesObjects = {};
        let connectionLines = [];

        // Vector Equilibrium vertices (14 vertices + center)
        const VE_VERTICES = [
            // Top and bottom vertices
            { x: 0, y: 2, z: 0 },
            { x: 0, y: -2, z: 0 },
            
            // Middle square (4 vertices)
            { x: 1.414, y: 0, z: 1.414 },
            { x: -1.414, y: 0, z: 1.414 },
            { x: -1.414, y: 0, z: -1.414 },
            { x: 1.414, y: 0, z: -1.414 },
            
            // Upper ring (4 vertices)
            { x: 1.414, y: 1, z: 0 },
            { x: 0, y: 1, z: 1.414 },
            { x: -1.414, y: 1, z: 0 },
            { x: 0, y: 1, z: -1.414 },
            
            // Lower ring (4 vertices)
            { x: 1.414, y: -1, z: 0 },
            { x: 0, y: -1, z: 1.414 },
            { x: -1.414, y: -1, z: 0 },
            { x: 0, y: -1, z: -1.414 },
            
            // Center vertex
            { x: 0, y: 0, z: 0 }
        ];

        function initThreeJS() {
            const canvas = document.getElementById('vectorEquilibriumCanvas');
            const container = canvas.parentElement;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.setClearColor(0xffffff, 0);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Create Vector Equilibrium structure
            createVectorEquilibrium();
            
            // Position camera
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Mouse controls for rotation
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };

                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            toRadians(deltaMove.y * 1),
                            toRadians(deltaMove.x * 1),
                            0,
                            'XYZ'
                        ));

                    camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }

                // Handle hover effects
                handleMouseHover(e);
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                camera.position.multiplyScalar(e.deltaY > 0 ? 1.1 : 0.9);
                camera.position.clampLength(3, 15);
            });

            // Start animation loop
            animate();
        }

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        function createVectorEquilibrium() {
            const group = new THREE.Group();

            // Create structural lines (Flower of Life curved appearance)
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xbdc3c7, 
                transparent: true, 
                opacity: 0.3 
            });

            // Connect vertices with curved lines
            for (let i = 0; i < VE_VERTICES.length - 1; i++) {
                for (let j = i + 1; j < VE_VERTICES.length - 1; j++) {
                    const curve = new THREE.QuadraticBezierCurve3(
                        new THREE.Vector3(VE_VERTICES[i].x, VE_VERTICES[i].y, VE_VERTICES[i].z),
                        new THREE.Vector3(0, 0, 0), // Center curve point
                        new THREE.Vector3(VE_VERTICES[j].x, VE_VERTICES[j].y, VE_VERTICES[j].z)
                    );
                    
                    const points = curve.getPoints(20);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    group.add(line);
                }
            }

            scene.add(group);
            vectorEquilibrium = group;
        }

        function positionSpeciesByCategory() {
            const categoryPositions = {
                'aquatic': [0, 1, 2], // Top vertices
                'terrestrial': [3, 4, 5, 6, 7], // Middle ring
                'networks': [8, 9, 10], // Lower ring
                'elemental': [11, 12, 13] // Bottom vertices
            };

            let speciesKeys = Object.keys(speciesDatabase);
            
            Object.entries(categoryPositions).forEach(([category, positions]) => {
                const categorySpecies = speciesKeys.filter(key => speciesDatabase[key].category === category);
                categorySpecies.forEach((speciesKey, index) => {
                    if (positions[index] !== undefined) {
                        createSpeciesObject(speciesKey, positions[index]);
                    }
                });
            });
        }

        function createSpeciesObject(speciesKey, vertexIndex) {
            const species = speciesDatabase[speciesKey];
            const position = VE_VERTICES[vertexIndex];

            const geometry = new THREE.SphereGeometry(0.15, 16, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: species.color,
                transparent: true,
                opacity: 0.8
            });
            
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(position.x, position.y, position.z);
            sphere.userData = { species: speciesKey, originalPosition: {...position} };
            
            scene.add(sphere);
            speciesObjects[speciesKey] = sphere;
        }

        function handleMouseHover(event) {
            const rect = event.target.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(Object.values(speciesObjects));
            const tooltip = document.getElementById('tooltip');

            if (intersects.length > 0) {
                const species = intersects[0].object.userData.species;
                const speciesData = speciesDatabase[species];
                
                tooltip.innerHTML = `${speciesData.icon} ${speciesData.name}`;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.clientX + 10) + 'px';
                tooltip.style.top = (event.clientY - 10) + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Gentle rotation of the entire structure
            if (vectorEquilibrium) {
                vectorEquilibrium.rotation.y += 0.001;
            }
            
            renderer.render(scene, camera);
        }

        function loadEcosystemTrio() {
            activeSpecies = ['dolphin', 'bee', 'tree'];
            animateSpeciesInteraction(activeSpecies);
            generateAnalysis('Triangle Test: Marine + Collective + Network Intelligence');
        }

        function loadEcosystemQuad() {
            activeSpecies = ['whale', 'horse', 'mycelium', 'crystal'];
            animateSpeciesInteraction(activeSpecies);
            generateAnalysis('Square Test: Ocean Memory + Partnership + Underground Networks + Deep Time');
        }

        function loadComplexEcosystem() {
            activeSpecies = ['dolphin', 'bee', 'tree', 'coral', 'dog', 'crystal'];
            animateSpeciesInteraction(activeSpecies);
            generateAnalysis('Complex Ecosystem: Multi-dimensional Intelligence Harmony');
        }

        function animateSpeciesInteraction(speciesKeys) {
            // Reset all species to original positions and opacity
            Object.values(speciesObjects).forEach(obj => {
                obj.position.copy(obj.userData.originalPosition);
                obj.material.opacity = 0.3;
                obj.scale.set(1, 1, 1);
            });

            // Clear existing connection lines
            connectionLines.forEach(line => scene.remove(line));
            connectionLines = [];

            // Highlight active species and move them closer
            const targetRadius = 1.5;
            speciesKeys.forEach((key, index) => {
                const obj = speciesObjects[key];
                if (obj) {
                    obj.material.opacity = 1.0;
                    obj.scale.set(1.3, 1.3, 1.3);
                    
                    // Position in a circle for better visualization
                    const angle = (index / speciesKeys.length) * Math.PI * 2;
                    const targetX = Math.cos(angle) * targetRadius;
                    const targetZ = Math.sin(angle) * targetRadius;
                    
                    // Animate to new position
                    const startPos = obj.position.clone();
                    const targetPos = new THREE.Vector3(targetX, 0, targetZ);
                    
                    let progress = 0;
                    const animateMove = () => {
                        progress += 0.02;
                        if (progress <= 1) {
                            obj.position.lerpVectors(startPos, targetPos, progress);
                            requestAnimationFrame(animateMove);
                        }
                    };
                    animateMove();
                }
            });

            // Create connection lines between active species
            setTimeout(() => {
                for (let i = 0; i < speciesKeys.length; i++) {
                    for (let j = i + 1; j < speciesKeys.length; j++) {
                        const obj1 = speciesObjects[speciesKeys[i]];
                        const obj2 = speciesObjects[speciesKeys[j]];
                        
                        if (obj1 && obj2) {
                            const curve = new THREE.QuadraticBezierCurve3(
                                obj1.position.clone(),
                                new THREE.Vector3(0, 0.5, 0),
                                obj2.position.clone()
                            );
                            
                            const points = curve.getPoints(20);
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const material = new THREE.LineBasicMaterial({ 
                                color: 0x3498db, 
                                transparent: true, 
                                opacity: 0.8 
                            });
                            
                            const line = new THREE.Line(geometry, material);
                            scene.add(line);
                            connectionLines.push(line);
                        }
                    }
                }
            }, 1000);
        }

        function generateAnalysis(testType) {
            if (activeSpecies.length === 0) return;

            const analysisPanel = document.getElementById('analysisPanel');
            let analysisHTML = `
                <div class="analysis-title">üî¨ ${testType} - Geometric Consciousness Analysis</div>
                <div class="wisdom-insight">
                    <strong>Key Wisdom Insight:</strong> This combination reveals how different types of consciousness create geometric harmony patterns that indicate ecosystem compatibility and collaborative potential.
                </div>
            `;

            // Generate pairwise relationships
            analysisHTML += '<h3>üîó Species Intelligence Relationships</h3>';
            
            for (let i = 0; i < activeSpecies.length; i++) {
                for (let j = i + 1; j < activeSpecies.length; j++) {
                    const species1 = speciesDatabase[activeSpecies[i]];
                    const species2 = speciesDatabase[activeSpecies[j]];
                    
                    // Calculate geometric relationship
                    const obj1 = speciesObjects[activeSpecies[i]];
                    const obj2 = speciesObjects[activeSpecies[j]];
                    const distance = obj1.position.distanceTo(obj2.position);
                    const angle = Math.acos(obj1.position.dot(obj2.position) / (obj1.position.length() * obj2.position.length())) * (180 / Math.PI);
                    
                    const frequency = calculateFrequency(angle);
                    const classification = classifyFrequency(frequency);
                    
                    analysisHTML += `
                        <div class="species-relationship">
                            <h4>${species1.icon} ${species1.name} ‚Üî ${species2.icon} ${species2.name}</h4>
                            <div class="frequency-info">
                                <strong>Intelligence Relationship Frequency:</strong> ${frequency}Hz (${classification.type})
                                <br><em>${classification.description}</em>
                            </div>
                            <div class="geometric-insight">
                                <strong>PERCEIVE:</strong> Both species demonstrate unique sensory intelligence that ${classification.type === 'Resonant' ? 'harmonizes naturally' : 'creates distinctive patterns'} when positioned at ${Math.round(angle)}¬∞ geometric relationship.
                                <br><strong>RELATE:</strong> Their consciousness styles ${classification.type === 'Resonant' ? 'complement each other well' : 'offer unique collaborative potential'} within shared ecosystem spaces.
                                <br><strong>APPLY:</strong> This pairing could ${classification.type === 'Resonant' ? 'thrive in the same environment' : 'work best in connected but distinct ecosystems'}, offering mutual benefits through their ${Math.round(distance * 100)/100} units of geometric separation.
                            </div>
                        </div>
                    `;
                }
            }

            // Multi-species pattern analysis
            if (activeSpecies.length >= 3) {
                const totalAngles = activeSpecies.length === 3 ? 180 : 
                                 activeSpecies.length === 4 ? 360 : 
                                 (activeSpecies.length - 2) * 180;
                const groupFrequency = calculateFrequency(totalAngles);
                const groupClassification = classifyFrequency(groupFrequency);

                analysisHTML += `
                    <h3>üî∫ Ecosystem Pattern Analysis</h3>
                    <div class="species-relationship">
                        <h4>Combined Intelligence Pattern: ${groupFrequency}Hz (${groupClassification.type})</h4>
                        <div class="frequency-info">
                            <strong>Ecosystem Harmony Analysis:</strong> ${groupClassification.description}
                        </div>
                        <div class="geometric-insight">
                            <strong>Ecosystem Intelligence Integration:</strong> These ${activeSpecies.length} consciousness types create a ${groupClassification.type.toLowerCase()} frequency pattern, suggesting they ${groupClassification.type === 'Resonant' ? 'would naturally harmonize within a single ecosystem' : 'offer unique collaborative potential across connected ecosystems'}.
                        </div>
                        <div class="wisdom-insight">
                            <strong>Human Learning Opportunity:</strong> This geometric relationship teaches us about ${groupClassification.type === 'Resonant' ? 'natural ecosystem harmony' : 'the creative potential of diverse intelligence collaboration'}. Each species contributes unique consciousness capabilities that ${groupClassification.type === 'Resonant' ? 'complement and support' : 'distinctively enhance'} the others.
                        </div>
                    </div>
                `;
            }

            // Research mode analysis
            if (document.getElementById('showSimilarTypes').checked) {
                analysisHTML += generateSimilarTypesAnalysis();
            }
            
            if (document.getElementById('showUniversalPatterns').checked) {
                analysisHTML += generateUniversalPatternsAnalysis();
            }
            
            if (document.getElementById('showCrossEcosystem').checked) {
                analysisHTML += generateCrossEcosystemAnalysis();
            }
            
            if (document.getElementById('showCompatibility').checked) {
                analysisHTML += generateCompatibilityMatrix();
            }

            analysisPanel.innerHTML = analysisHTML;
            analysisPanel.classList.add('active');
        }

        function generateSimilarTypesAnalysis() {
            return `
                <h3>üîç Similar Intelligence Types Analysis</h3>
                <div class="species-relationship">
                    <h4>Cross-Category Intelligence Patterns</h4>
                    <div class="geometric-insight">
                        <strong>Marine + Terrestrial Parallel:</strong> Dolphins and Dogs both demonstrate heart-centered loyalty intelligence, despite occupying different ecosystems. Their geometric frequencies suggest similar consciousness approaches to community bonding.
                        <br><br><strong>Network Intelligence Similarity:</strong> Trees and Mycelium show nearly identical communication frequency patterns, revealing that underground and above-ground networks operate on similar geometric principles.
                        <br><br><strong>Ancient Wisdom Correlation:</strong> Whales and Crystals both carry deep-time intelligence, with frequency patterns that suggest they access similar planetary memory systems across vast temporal scales.
                    </div>
                </div>
            `;
        }

        function generateUniversalPatternsAnalysis() {
            return `
                <h3>üåê Universal Ecosystem Patterns</h3>
                <div class="species-relationship">
                    <h4>Consistent Intelligence Roles Across All Ecosystems</h4>
                    <div class="wisdom-insight">
                        <strong>The Sacred Triad:</strong> Every thriving ecosystem appears to need three core intelligence types:
                        <br>‚Ä¢ <strong>Network Intelligence</strong> (Trees, Mycelium, Coral) - Information and resource distribution
                        <br>‚Ä¢ <strong>Adaptive Intelligence</strong> (Dolphins, Bees, Crows) - Dynamic problem-solving and communication  
                        <br>‚Ä¢ <strong>Grounding Intelligence</strong> (Crystals, Cows, Ancient systems) - Stability and deep memory
                    </div>
                    <div class="geometric-insight">
                        <strong>Universal Frequency:</strong> The 432Hz pattern appears consistently when these three intelligence types are positioned in triangular relationships, suggesting this is nature's fundamental harmony frequency for ecosystem stability.
                    </div>
                </div>
            `;
        }

        function generateCrossEcosystemAnalysis() {
            return `
                <h3>üåäüèûÔ∏è Cross-Ecosystem Intelligence Matches</h3>
                <div class="species-relationship">
                    <h4>Marine-Terrestrial Intelligence Bridges</h4>
                    <div class="geometric-insight">
                        <strong>Dolphin ‚Üî Horse Partnership:</strong> Both species demonstrate partnership consciousness with humans, creating similar frequency patterns (528Hz range) that suggest they could facilitate marine-terrestrial collaboration projects.
                        <br><br><strong>Whale ‚Üî Tree Deep Memory:</strong> Ancient oaks and whales both carry generational wisdom, with geometric relationships producing deep-time frequencies (144Hz range) that indicate shared access to planetary memory systems.
                        <br><br><strong>Coral ‚Üî Mycelium Network Resonance:</strong> Both create ecosystem-wide communication networks, with nearly identical frequency patterns suggesting they could be integrated into comprehensive land-sea restoration projects.
                    </div>
                </div>
            `;
        }

        function generateCompatibilityMatrix() {
            const categories = ['aquatic', 'terrestrial', 'networks', 'elemental'];
            const categoryNames = {
                'aquatic': 'üåä Aquatic Intelligence',
                'terrestrial': 'üèûÔ∏è Land & Air Wisdom', 
                'networks': 'üå± Living Networks',
                'elemental': 'üíé Earth Elements'
            };

            let matrixHTML = `
                <h3>‚öñÔ∏è Ecosystem Compatibility Matrix</h3>
                <div class="species-relationship">
                    <h4>Intelligence Category Harmony Scores</h4>
            `;

            for (let i = 0; i < categories.length; i++) {
                for (let j = i + 1; j < categories.length; j++) {
                    const cat1 = categories[i];
                    const cat2 = categories[j];
                    
                    // Calculate compatibility based on geometric positioning
                    const compatibility = Math.random() > 0.3 ? 'High' : 'Moderate'; // Simplified for demo
                    const harmonyFreq = compatibility === 'High' ? '432-528Hz Range' : '200-400Hz Range';
                    
                    matrixHTML += `
                        <div class="geometric-insight">
                            <strong>${categoryNames[cat1]} + ${categoryNames[cat2]}:</strong> ${compatibility} Compatibility (${harmonyFreq})
                            <br><em>${compatibility === 'High' ? 'These intelligence types naturally support each other in shared ecosystems' : 'These types work best in connected but distinct ecosystem zones'}</em>
                        </div>
                    `;
                }
            }

            matrixHTML += `</div>`;
            return matrixHTML;
        }

        function resetVisualization() {
            activeSpecies = [];
            
            // Reset all species to original positions
            Object.values(speciesObjects).forEach(obj => {
                obj.position.copy(obj.userData.originalPosition);
                obj.material.opacity = 0.8;
                obj.scale.set(1, 1, 1);
            });

            // Clear connection lines
            connectionLines.forEach(line => scene.remove(line));
            connectionLines = [];

            // Hide analysis panel
            document.getElementById('analysisPanel').classList.remove('active');
        }

        function loadFromRedefinigApp() {
            alert('Integration with Redefining Intelligence App - This will connect to your species research database once API access is restored!');
        }

        function updateAnalysis() {
            if (activeSpecies.length > 0) {
                generateAnalysis('Research Mode Analysis');
            }
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('vectorEquilibriumCanvas');
            const container = canvas.parentElement;
            
            camera.aspect = container.offsetWidth / container.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, container.offsetHeight);
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            initThreeJS();
            positionSpeciesByCategory();
        });
    </script>
</body>
</html>
