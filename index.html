<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated Intelligence Map - Vector Equilibrium Sacred Geometry</title>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Poppins Font -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #2a1a4a 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 1.8em;
            background: linear-gradient(135deg, #ff6b9d, #c5a3ff, #6bcf7f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .header p {
            font-size: 0.9em;
            color: #b0b0b0;
            font-style: italic;
        }

        .controls {
            position: absolute;
            top: 120px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 280px;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: #ff6b9d;
            font-size: 1em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .dimension-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .dimension-btn {
            background: rgba(255, 107, 157, 0.2);
            border: 1px solid #ff6b9d;
            color: #ff6b9d;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .dimension-btn:hover {
            background: rgba(255, 107, 157, 0.3);
            transform: translateY(-2px);
        }

        .current-dimension {
            color: #6bcf7f;
            font-weight: 600;
        }

        .species-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .species-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .species-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .species-item.selected {
            background: rgba(107, 207, 127, 0.3);
            border: 1px solid #6bcf7f;
        }

        .data-controls {
            position: absolute;
            top: 120px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 250px;
        }

        .load-btn {
            background: linear-gradient(135deg, #6bcf7f, #4a9d5f);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            margin: 5px 0;
            transition: all 0.3s ease;
        }

        .load-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(107, 207, 127, 0.3);
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
            display: none;
        }

        .info-panel.show {
            display: block;
        }

        .info-panel h4 {
            color: #c5a3ff;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .info-panel p {
            font-size: 0.9em;
            line-height: 1.4;
            color: #d0d0d0;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }

        .loading-animation {
            font-size: 48px;
            animation: pulse 2s infinite;
            margin-bottom: 20px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 0.8em;
            color: #b0b0b0;
            max-width: 200px;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 107, 157, 0.5);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 107, 157, 0.8);
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>üå∏ Integrated Intelligence Map</h1>
            <p>Vector Equilibrium Sacred Geometry ‚Ä¢ Redefining Intelligence Through Relational Consciousness</p>
        </header>

        <div class="controls">
            <div class="control-section">
                <h3>üîÆ Consciousness Dimensions</h3>
                <div class="dimension-controls">
                    <button class="dimension-btn" onclick="changeDimension(-1)">-</button>
                    <span class="current-dimension" id="currentDimension">Dimension 1: Sensory Awareness</span>
                    <button class="dimension-btn" onclick="changeDimension(1)">+</button>
                </div>
                <div style="font-size: 0.8em; color: #b0b0b0; margin-top: 5px;">
                    Navigate 12 dimensions of intelligence
                </div>
            </div>

            <div class="control-section">
                <h3>üåå Sacred Geometry</h3>
                <button class="load-btn" onclick="resetView()">üå∏ Reset to Flower of Life</button>
                <button class="load-btn" onclick="toggleConnections()">‚ö° Toggle Connections</button>
                <button class="load-btn" onclick="animateConstellation()">üåÄ Animate Tesla 369</button>
            </div>

            <div class="control-section">
                <h3>üëÅÔ∏è Focus Species</h3>
                <div class="species-list" id="speciesList">
                    <!-- Species will be populated here -->
                </div>
            </div>
        </div>

        <div class="data-controls">
            <div class="control-section">
                <h3>üìä Data Integration</h3>
                <button class="load-btn" onclick="loadSampleData()">üß¨ Load Sample Species</button>
                <button class="load-btn" onclick="loadFromResearchApp()">üî¨ Load from Research App</button>
                <button class="load-btn" onclick="exportConstellationData()">üíæ Export Sacred Geometry</button>
            </div>

            <div class="control-section">
                <h3>üéµ Tesla Frequencies</h3>
                <div style="font-size: 0.8em; color: #c5a3ff;">
                    <div>396 Hz - Transformation</div>
                    <div>528 Hz - Love/DNA Repair</div>
                    <div>741 Hz - Intuition</div>
                    <div>963 Hz - Unity</div>
                </div>
            </div>
        </div>

        <div class="info-panel" id="infoPanel">
            <h4 id="infoTitle">Species Information</h4>
            <p id="infoContent">Hover over species nodes to see consciousness insights</p>
        </div>

        <div class="canvas-container">
            <div class="loading" id="loading">
                <div class="loading-animation">üå∏</div>
                <h3>Initializing Sacred Geometry...</h3>
                <p>Preparing Vector Equilibrium Consciousness Map</p>
            </div>
            <canvas id="geometryCanvas"></canvas>
        </div>

        <div class="instructions">
            <strong>Sacred Navigation:</strong><br>
            ‚Ä¢ Drag to rotate the vector equilibrium<br>
            ‚Ä¢ Scroll to zoom consciousness layers<br>
            ‚Ä¢ Click species for detailed insights<br>
            ‚Ä¢ Use +/- to explore 12 dimensions
        </div>
    </div>

    <script>
        // ====== SACRED GEOMETRY DATA STRUCTURES ======
        let scene, camera, renderer, vectorEquilibrium;
        let speciesNodes = [];
        let connectionLines = [];
        let currentDimension = 1;
        let animationRunning = false;
        let showConnections = true;
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        // 12 Sacred Dimensions of Consciousness
        const SACRED_DIMENSIONS = [
            { id: 1, name: "Sensory Awareness", description: "Physical and energetic sensing capabilities" },
            { id: 2, name: "Intuitive Reception", description: "Non-linear information awareness" },
            { id: 3, name: "Temporal Perception", description: "Time and predictive consciousness" },
            { id: 4, name: "Emotional Resonance", description: "Empathic connection and feeling-based communication" },
            { id: 5, name: "Energetic Attunement", description: "Frequency matching and quantum entanglement" },
            { id: 6, name: "Environmental Consciousness", description: "Ecosystem awareness and spatial intelligence" },
            { id: 7, name: "Symbolic Communication", description: "Non-verbal, gestural, artistic expression" },
            { id: 8, name: "Collaborative Intelligence", description: "Group consciousness and hive mind" },
            { id: 9, name: "Creative Innovation", description: "Problem-solving, adaptation, biomimicry" },
            { id: 10, name: "Healing Wisdom", description: "Therapeutic application and restoration" },
            { id: 11, name: "Teaching Capacity", description: "Knowledge transmission and skill sharing" },
            { id: 12, name: "Evolutionary Contribution", description: "Species advancement and consciousness evolution" }
        ];

        // Tesla Sacred Frequencies
        const TESLA_FREQUENCIES = {
            396: { name: "Liberation", color: 0xff6b9d },
            528: { name: "Transformation", color: 0x6bcf7f },
            741: { name: "Intuition", color: 0xc5a3ff },
            963: { name: "Unity", color: 0xffd700 }
        };

        // Sample Species Data for Testing
        const SAMPLE_SPECIES = [
            {
                name: "Dolphin",
                dimensions: [10, 11, 9, 12, 11, 10, 9, 11, 8, 10, 9, 11],
                frequency: 528,
                wisdomInsight: "Masters of sonar consciousness and joyful communication",
                color: 0x4a9eff
            },
            {
                name: "Honeybee",
                dimensions: [9, 7, 8, 8, 9, 11, 10, 12, 9, 8, 10, 10],
                frequency: 741,
                wisdomInsight: "Sacred geometry architects of collective intelligence",
                color: 0xffd700
            },
            {
                name: "Ancient Oak",
                dimensions: [8, 9, 12, 7, 10, 12, 8, 9, 7, 11, 11, 12],
                frequency: 396,
                wisdomInsight: "Timekeepers and wisdom holders of forest consciousness",
                color: 0x6b8e23
            },
            {
                name: "Octopus",
                dimensions: [11, 10, 8, 9, 8, 10, 11, 7, 12, 9, 8, 9],
                frequency: 963,
                wisdomInsight: "Shape-shifting masters of adaptive intelligence",
                color: 0x9932cc
            },
            {
                name: "Human",
                dimensions: [8, 9, 9, 9, 7, 8, 11, 9, 10, 8, 10, 9],
                frequency: 528,
                wisdomInsight: "Bridge consciousness seeking harmony with all life",
                color: 0xff6b6b
            },
            {
                name: "Wolf",
                dimensions: [10, 8, 9, 11, 9, 10, 9, 12, 9, 8, 11, 10],
                frequency: 741,
                wisdomInsight: "Pack consciousness teachers of loyalty and cooperation",
                color: 0x708090
            }
        ];

        // ====== SACRED GEOMETRY INITIALIZATION ======
        function initSacredGeometry() {
            const canvas = document.getElementById('geometryCanvas');
            const container = canvas.parentElement;
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create Vector Equilibrium framework
            createVectorEquilibrium();
            
            // Add cosmic background particles
            createCosmicBackground();
            
            // Setup controls
            setupMouseControls();
            
            // Start animation
            animate();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
        }

        function createVectorEquilibrium() {
            vectorEquilibrium = new THREE.Group();
            
            // Create the 12 vertices of vector equilibrium using sacred geometry
            const vertices = [];
            const radius = 8;
            
            // Hexagonal pattern vertices (6)
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                vertices.push(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                ));
            }
            
            // Top and bottom vertices (2)
            vertices.push(new THREE.Vector3(0, 0, radius));
            vertices.push(new THREE.Vector3(0, 0, -radius));
            
            // Additional vertices for complete vector equilibrium (4)
            const innerRadius = radius * 0.5;
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                vertices.push(new THREE.Vector3(
                    Math.cos(angle) * innerRadius,
                    Math.sin(angle) * innerRadius,
                    0
                ));
            }
            
            // Draw the framework lines
            const frameGeometry = new THREE.BufferGeometry();
            const framePositions = [];
            
            // Connect vertices to form vector equilibrium structure
            const connections = [
                [0,1], [1,2], [2,3], [3,4], [4,5], [5,0], // Outer hexagon
                [6,7], // Top-bottom axis
                [0,6], [2,6], [4,6], // Top connections
                [1,7], [3,7], [5,7], // Bottom connections
                [8,9], [9,10], [10,11], [11,8], // Inner square
                [0,8], [1,9], [2,10], [3,11] // Outer to inner connections
            ];
            
            connections.forEach(([start, end]) => {
                framePositions.push(vertices[start].x, vertices[start].y, vertices[start].z);
                framePositions.push(vertices[end].x, vertices[end].y, vertices[end].z);
            });
            
            frameGeometry.setAttribute('position', new THREE.Float32BufferAttribute(framePositions, 3));
            
            const frameMaterial = new THREE.LineBasicMaterial({
                color: 0x444444,
                transparent: true,
                opacity: 0.3
            });
            
            const frameLines = new THREE.LineSegments(frameGeometry, frameMaterial);
            vectorEquilibrium.add(frameLines);
            
            scene.add(vectorEquilibrium);
        }

        function createCosmicBackground() {
            const particleCount = 1000;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = [];
            
            for (let i = 0; i < particleCount; i++) {
                particlePositions.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
            }
            
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x888888,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // ====== SPECIES CONSCIOUSNESS MAPPING ======
        function addSpeciesToConstellation(speciesData) {
            // Calculate position based on consciousness dimensions using sacred geometry
            const position = calculateSacredPosition(speciesData.dimensions, currentDimension);
            
            // Create species node
            const nodeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const nodeMaterial = new THREE.MeshPhongMaterial({
                color: speciesData.color,
                transparent: true,
                opacity: 0.8,
                emissive: new THREE.Color(speciesData.color).multiplyScalar(0.1)
            });
            
            const speciesNode = new THREE.Mesh(nodeGeometry, nodeMaterial);
            speciesNode.position.copy(position);
            speciesNode.userData = {
                species: speciesData.name,
                dimensions: speciesData.dimensions,
                frequency: speciesData.frequency,
                wisdomInsight: speciesData.wisdomInsight,
                originalPosition: position.clone()
            };
            
            // Add pulsing animation based on Tesla frequency
            const frequency = speciesData.frequency;
            const pulseRate = frequency / 1000; // Convert Hz to animation rate
            speciesNode.userData.pulseRate = pulseRate;
            
            vectorEquilibrium.add(speciesNode);
            speciesNodes.push(speciesNode);
            
            return speciesNode;
        }

        function calculateSacredPosition(dimensions, focusDimension) {
            // Use the focused dimension and its neighbors for positioning
            const primary = dimensions[focusDimension - 1] / 12; // Normalize to 0-1
            const secondary = dimensions[(focusDimension % 12)] / 12;
            const tertiary = dimensions[(focusDimension + 1) % 12] / 12;
            
            // Sacred geometry positioning using flower of life principles
            const radius = 6 + primary * 2; // Distance from center
            const angle1 = secondary * Math.PI * 2; // Horizontal angle
            const angle2 = (tertiary - 0.5) * Math.PI; // Vertical angle
            
            return new THREE.Vector3(
                Math.cos(angle1) * Math.cos(angle2) * radius,
                Math.sin(angle1) * Math.cos(angle2) * radius,
                Math.sin(angle2) * radius
            );
        }

        function createConnectionLines() {
            // Clear existing connections
            connectionLines.forEach(line => vectorEquilibrium.remove(line));
            connectionLines = [];
            
            if (!showConnections || speciesNodes.length < 2) return;
            
            // Create curved connections between related species
            for (let i = 0; i < speciesNodes.length; i++) {
                for (let j = i + 1; j < speciesNodes.length; j++) {
                    const species1 = speciesNodes[i];
                    const species2 = speciesNodes[j];
                    
                    // Calculate consciousness similarity
                    const similarity = calculateConsciousnessSimilarity(
                        species1.userData.dimensions,
                        species2.userData.dimensions
                    );
                    
                    if (similarity > 0.6) { // Only show strong connections
                        const connection = createCurvedConnection(species1, species2, similarity);
                        vectorEquilibrium.add(connection);
                        connectionLines.push(connection);
                    }
                }
            }
        }

        function calculateConsciousnessSimilarity(dims1, dims2) {
            let similarity = 0;
            for (let i = 0; i < 12; i++) {
                const diff = Math.abs(dims1[i] - dims2[i]);
                similarity += (12 - diff) / 12;
            }
            return similarity / 12;
        }

        function createCurvedConnection(node1, node2, strength) {
            const pos1 = node1.position;
            const pos2 = node2.position;
            
            // Create curved path using quadratic bezier
            const midPoint = new THREE.Vector3().addVectors(pos1, pos2).multiplyScalar(0.5);
            const curve = new THREE.QuadraticBezierCurve3(
                pos1.clone(),
                midPoint.clone().add(new THREE.Vector3(0, 0, 2)),
                pos2.clone()
            );
            
            const points = curve.getPoints(20);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            
            const material = new THREE.LineBasicMaterial({
                color: 0x6bcf7f,
                transparent: true,
                opacity: strength * 0.5
            });
            
            return new THREE.Line(geometry, material);
        }

        // ====== INTERACTION CONTROLS ======
        function setupMouseControls() {
            const canvas = document.getElementById('geometryCanvas');
            
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            canvas.addEventListener('wheel', onMouseWheel, false);
            
            // Touch controls for mobile
            canvas.addEventListener('touchstart', onTouchStart, false);
            canvas.addEventListener('touchmove', onTouchMove, false);
            canvas.addEventListener('touchend', onTouchEnd, false);
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            vectorEquilibrium.rotation.y += deltaX * 0.01;
            vectorEquilibrium.rotation.x += deltaY * 0.01;
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp(event) {
            isMouseDown = false;
        }

        function onMouseWheel(event) {
            const zoomSpeed = 0.1;
            camera.position.z += event.deltaY * zoomSpeed;
            camera.position.z = Math.max(5, Math.min(30, camera.position.z));
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                isMouseDown = true;
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;
                
                vectorEquilibrium.rotation.y += deltaX * 0.01;
                vectorEquilibrium.rotation.x += deltaY * 0.01;
                
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }

        function onTouchEnd(event) {
            isMouseDown = false;
        }

        // ====== UI CONTROL FUNCTIONS ======
        function changeDimension(direction) {
            currentDimension += direction;
            if (currentDimension < 1) currentDimension = 12;
            if (currentDimension > 12) currentDimension = 1;
            
            const dimension = SACRED_DIMENSIONS[currentDimension - 1];
            document.getElementById('currentDimension').textContent = 
                `Dimension ${dimension.id}: ${dimension.name}`;
            
            // Reposition species based on new dimension focus
            repositionSpecies();
        }

        function repositionSpecies() {
            speciesNodes.forEach(node => {
                const newPosition = calculateSacredPosition(node.userData.dimensions, currentDimension);
                
                // Smooth transition
                const tween = { x: node.position.x, y: node.position.y, z: node.position.z };
                const target = { x: newPosition.x, y: newPosition.y, z: newPosition.z };
                
                // Simple linear interpolation for smooth movement
                const animate = () => {
                    const step = 0.1;
                    tween.x += (target.x - tween.x) * step;
                    tween.y += (target.y - tween.y) * step;
                    tween.z += (target.z - tween.z) * step;
                    
                    node.position.set(tween.x, tween.y, tween.z);
                    
                    if (Math.abs(target.x - tween.x) > 0.01) {
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            });
            
            // Recreate connections after repositioning
            setTimeout(() => createConnectionLines(), 500);
        }

        function loadSampleData() {
            // Clear existing species
            clearSpecies();
            
            // Add sample species to constellation
            SAMPLE_SPECIES.forEach(species => {
                addSpeciesToConstellation(species);
            });
            
            // Create connections
            setTimeout(() => createConnectionLines(), 100);
            
            // Update species list UI
            updateSpeciesList();
            
            showNotification("‚ú® Sample species loaded into sacred geometry constellation!");
        }

        function loadFromResearchApp() {
            // Try to load data from localStorage (Research App integration)
            try {
                const researchHistory = JSON.parse(localStorage.getItem('researchHistory') || '[]');
                const intelligenceVectors = JSON.parse(localStorage.getItem('intelligenceVectors') || '{}');
                
                if (Object.keys(intelligenceVectors).length === 0) {
                    showNotification("üî¨ No research data found. Please use the Species Intelligence Research App first, then return here!");
                    return;
                }
                
                // Clear existing species
                clearSpecies();
                
                // Convert research data to our 12-dimensional format
                Object.values(intelligenceVectors).forEach(vector => {
                    const speciesData = convertResearchDataToSacredGeometry(vector);
                    addSpeciesToConstellation(speciesData);
                });
                
                // Create connections
                setTimeout(() => createConnectionLines(), 100);
                updateSpeciesList();
                
                showNotification(`üå∏ Loaded ${Object.keys(intelligenceVectors).length} species from Research App into sacred geometry!`);
                
            } catch (error) {
                console.error('Error loading research data:', error);
                showNotification("‚ùå Error loading research data. Please try again.");
            }
        }

        function convertResearchDataToSacredGeometry(vector) {
            // Convert 6-dimensional research data to our 12-dimensional sacred geometry
            const dimensions = [
                (vector.perceive || 0.5) * 12,           // 1. Sensory Awareness
                (vector.perceive || 0.5) * 12,           // 2. Intuitive Reception
                (vector.temporal || 0.5) * 12,           // 3. Temporal Perception
                (vector.relate || 0.5) * 12,             // 4. Emotional Resonance
                (vector.energetic || 0.5) * 12,          // 5. Energetic Attunement
                (vector.relate || 0.5) * 12,             // 6. Environmental Consciousness
                (vector.relate || 0.5) * 12,             // 7. Symbolic Communication
                (vector.collective || 0.5) * 12,         // 8. Collaborative Intelligence
                (vector.apply || 0.5) * 12,              // 9. Creative Innovation
                (vector.apply || 0.5) * 12,              // 10. Healing Wisdom
                (vector.adaptive || 0.5) * 12,           // 11. Teaching Capacity
                (vector.complexity || 0.5) * 12          // 12. Evolutionary Contribution
            ];
            
            // Assign Tesla frequency based on species characteristics
            let frequency = 528; // Default transformation frequency
            if (vector.collective > 0.8) frequency = 741; // High collective = intuition frequency
            if (vector.uniqueness > 0.8) frequency = 963; // High uniqueness = unity frequency
            if (vector.temporal > 0.8) frequency = 396;   // High temporal = liberation frequency
            
            // Assign color based on frequency
            const colorMap = {
                396: 0xff6b9d,  // Pink
                528: 0x6bcf7f,  // Green
                741: 0xc5a3ff,  // Purple
                963: 0xffd700   // Gold
            };
            
            return {
                name: vector.species,
                dimensions: dimensions,
                frequency: frequency,
                wisdomInsight: `${vector.species} demonstrates ${vector.complexity > 0.7 ? 'extraordinary' : 'remarkable'} consciousness across multiple intelligence dimensions.`,
                color: colorMap[frequency]
            };
        }

        function clearSpecies() {
            speciesNodes.forEach(node => vectorEquilibrium.remove(node));
            connectionLines.forEach(line => vectorEquilibrium.remove(line));
            speciesNodes = [];
            connectionLines = [];
            updateSpeciesList();
        }

        function updateSpeciesList() {
            const speciesList = document.getElementById('speciesList');
            speciesList.innerHTML = '';
            
            speciesNodes.forEach((node, index) => {
                const item = document.createElement('div');
                item.className = 'species-item';
                item.innerHTML = `
                    <div style="font-weight: 600;">${node.userData.species}</div>
                    <div style="font-size: 0.8em; opacity: 0.7;">${node.userData.frequency}Hz ‚Ä¢ ${TESLA_FREQUENCIES[node.userData.frequency]?.name || 'Sacred'}</div>
                `;
                item.onclick = () => focusOnSpecies(index);
                speciesList.appendChild(item);
            });
        }

        function focusOnSpecies(index) {
            const node = speciesNodes[index];
            if (!node) return;
            
            // Smooth camera movement to focus on species
            const targetPosition = node.position.clone().add(new THREE.Vector3(0, 0, 5));
            animateCameraTo(targetPosition);
            
            // Show species information
            showSpeciesInfo(node.userData);
            
            // Highlight the selected species
            document.querySelectorAll('.species-item').forEach(item => item.classList.remove('selected'));
            document.querySelectorAll('.species-item')[index].classList.add('selected');
        }

        function showSpeciesInfo(userData) {
            const infoPanel = document.getElementById('infoPanel');
            const infoTitle = document.getElementById('infoTitle');
            const infoContent = document.getElementById('infoContent');
            
            infoTitle.textContent = userData.species;
            infoContent.innerHTML = `
                <div style="margin-bottom: 10px;"><strong>Wisdom:</strong> ${userData.wisdomInsight}</div>
                <div style="margin-bottom: 10px;"><strong>Tesla Frequency:</strong> ${userData.frequency}Hz (${TESLA_FREQUENCIES[userData.frequency]?.name || 'Sacred'})</div>
                <div><strong>Current Dimension Focus:</strong> ${SACRED_DIMENSIONS[currentDimension - 1].name}</div>
                <div style="margin-top: 10px; font-size: 0.8em; opacity: 0.8;">${SACRED_DIMENSIONS[currentDimension - 1].description}</div>
            `;
            
            infoPanel.classList.add('show');
        }

        function animateCameraTo(targetPosition) {
            const startPosition = camera.position.clone();
            const duration = 1000; // 1 second
            const startTime = Date.now();
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                
                camera.position.lerpVectors(startPosition, targetPosition, eased);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            
            updateCamera();
        }

        function resetView() {
            camera.position.set(0, 0, 15);
            camera.lookAt(0, 0, 0);
            vectorEquilibrium.rotation.set(0, 0, 0);
            
            // Hide species info
            document.getElementById('infoPanel').classList.remove('show');
            
            showNotification("üå∏ View reset to Flower of Life center");
        }

        function toggleConnections() {
            showConnections = !showConnections;
            createConnectionLines();
            
            showNotification(showConnections ? "‚ö° Connections enabled" : "‚ö° Connections hidden");
        }

        function animateConstellation() {
            if (animationRunning) return;
            
            animationRunning = true;
            const duration = 6000; // 6 seconds for full Tesla 369 cycle
            const startTime = Date.now();
            
            function teslaAnimation() {
                const elapsed = Date.now() - startTime;
                const progress = (elapsed % duration) / duration;
                
                // Tesla 3-6-9 rotation pattern
                const rotation = progress * Math.PI * 2;
                vectorEquilibrium.rotation.y = rotation;
                vectorEquilibrium.rotation.x = Math.sin(rotation * 3) * 0.2; // 3x frequency
                vectorEquilibrium.rotation.z = Math.cos(rotation * 6) * 0.1; // 6x frequency
                
                // Pulsing effect based on 9
                const pulse = Math.sin(rotation * 9) * 0.1 + 1;
                vectorEquilibrium.scale.setScalar(pulse);
                
                if (elapsed < duration) {
                    requestAnimationFrame(teslaAnimation);
                } else {
                    animationRunning = false;
                    vectorEquilibrium.scale.setScalar(1);
                    showNotification("üåÄ Tesla 369 animation complete");
                }
            }
            
            teslaAnimation();
            showNotification("üåÄ Tesla 369 animation started");
        }

        function exportConstellationData() {
            const exportData = {
                metadata: {
                    title: "Integrated Intelligence Map - Sacred Geometry Export",
                    generatedAt: new Date().toISOString(),
                    speciesCount: speciesNodes.length,
                    currentDimension: currentDimension,
                    framework: "Vector Equilibrium Consciousness Mapping"
                },
                sacredDimensions: SACRED_DIMENSIONS,
                teslaFrequencies: TESLA_FREQUENCIES,
                species: speciesNodes.map(node => ({
                    name: node.userData.species,
                    dimensions: node.userData.dimensions,
                    frequency: node.userData.frequency,
                    position: {
                        x: node.position.x,
                        y: node.position.y,
                        z: node.position.z
                    },
                    wisdomInsight: node.userData.wisdomInsight
                })),
                connections: connectionLines.length
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `integrated-intelligence-map-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            showNotification("üíæ Sacred geometry data exported successfully!");
        }

        function showNotification(message) {
            // Create temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.9);
                color: #6bcf7f;
                padding: 15px 25px;
                border-radius: 10px;
                border: 1px solid #6bcf7f;
                z-index: 1000;
                font-family: 'Poppins', sans-serif;
                font-weight: 500;
                backdrop-filter: blur(10px);
                animation: slideIn 0.3s ease-out;
            `;
            notification.textContent = message;
            
            // Add slide-in animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => {
                    document.body.removeChild(notification);
                    document.head.removeChild(style);
                }, 300);
            }, 3000);
        }

        // ====== ANIMATION LOOP ======
        function animate() {
            requestAnimationFrame(animate);
            
            // Gentle rotation when not being manually controlled
            if (!isMouseDown && !animationRunning) {
                vectorEquilibrium.rotation.y += 0.002;
            }
            
            // Pulse species nodes based on their Tesla frequencies
            speciesNodes.forEach(node => {
                const time = Date.now() * 0.001;
                const pulseRate = node.userData.pulseRate || 0.5;
                const pulse = Math.sin(time * pulseRate) * 0.1 + 1;
                node.scale.setScalar(pulse);
                
                // Add subtle floating motion
                const float = Math.sin(time * 0.5 + node.position.x) * 0.1;
                node.position.y = node.userData.originalPosition.y + float;
            });
            
            // Render the scene
            renderer.render(scene, camera);
        }

        // ====== WINDOW RESIZE HANDLER ======
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ====== INITIALIZATION ======
        window.addEventListener('load', initSacredGeometry);
        window.addEventListener('resize', onWindowResize);

        // Make functions globally accessible
        window.changeDimension = changeDimension;
        window.loadSampleData = loadSampleData;
        window.loadFromResearchApp = loadFromResearchApp;
        window.resetView = resetView;
        window.toggleConnections = toggleConnections;
        window.animateConstellation = animateConstellation;
        window.exportConstellationData = exportConstellationData;
    </script>
</body>
</html>
